"""
Script for executing SQL migration files from AWS Schema Conversion Tool output.

This script processes SQL migration files generated by AWS Schema Conversion Tool,
executing them against a target PostgreSQL database. It:
- Iterates through batch folders in the 'converted_db_objects' directory
- Executes SQL files within each batch folder
- Generates execution reports with success/failure statistics
- Creates a detailed report file for each batch folder
- Handles database connections and transaction rollbacks on errors

The script is designed to be used as part of a database migration process,
providing visibility into the execution status of converted database objects.
"""

import os
import psycopg2

# Database connection parameters
DB_PARAMS = {
    'dbname': 'db_name',
    'user': 'db_user',
    'password': 'db_password',
    'host': 'host_name',
    'port': 5555
}

# Root directory containing the batch folders
ROOT_DIR = 'converted_db_objects'

def execute_sql_file(file_path, connection):
    """Executes a single SQL file and returns success status and error message, if any."""
    try:
        with open(file_path, 'r') as sql_file:
            sql_content = sql_file.read()
        with connection.cursor() as cursor:
            cursor.execute(sql_content)
        connection.commit()
        return True, None  # Success
    except Exception as e:
        connection.rollback()
        return False, str(e)  # Failure and error message

def process_batch_folder(batch_folder_path, connection):
    """Processes all SQL files in a batch folder, generates a report, and includes statistics."""
    report = []  # [] To store the execution results
    success_count = 0
    failure_count = 0

    # Iterate over all SQL files in the batch folder
    for file_name in os.listdir(batch_folder_path):
        if file_name.endswith('.sql'):
            file_path = os.path.join(batch_folder_path, file_name)
            status, error_message = execute_sql_file(file_path, connection)

            # Update counts based on execution status
            if status:
                success_count += 1
            else:
                failure_count += 1

            report.append({
                'file': file_name,
                'status': 'Success' if status else 'Failed',
                'error': error_message
            })

    # Write the report to a file in the batch folder
    report_file_path = os.path.join(batch_folder_path, 'execution_report.txt')
    with open(report_file_path, 'w') as report_file:
        # Write statistics
        total_files = success_count + failure_count
        report_file.write(f"Total SQL files: {total_files}\n")
        report_file.write(f"Successful executions: {success_count}\n")
        report_file.write(f"Failed executions: {failure_count}\n\n")

        # Write details for each file
        for entry in report:
            report_file.write(f"File: {entry['file']}, Status: {entry['status']}\n")
            if entry['status'] == 'Failed':
                report_file.write(f"Error: {entry['error']}\n")

def main():
    # Establish connection to the database
    try:
        connection = psycopg2.connect(**DB_PARAMS)
    except Exception as db_error:
        print(f"Failed to connect to the database: {db_error}")
        return

    # Iterate over batch folders in the root directory
    for batch_folder in os.listdir(ROOT_DIR):
        if not os.path.isdir(os.path.join(ROOT_DIR, batch_folder)):
            continue

        batch_folder_path = os.path.join(ROOT_DIR, batch_folder)
        execution_report_path = os.path.join(batch_folder_path, 'execution_report.txt')

        # Ensure it's a folder and skip if report already exists
        if os.path.isfile(execution_report_path):
            continue

        print(f"Processing batch folder: {batch_folder}")
        process_batch_folder(batch_folder_path, connection)

    # Close the database connection
    connection.close()
    print("Execution complete. Reports with statistics have been generated in each batch folder.")

if __name__ == "__main__":
    main()